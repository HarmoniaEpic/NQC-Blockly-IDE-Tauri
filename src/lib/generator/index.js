import * as Blockly from 'blockly';

export function initializeNqcGenerator() {
  const nqcGenerator = new Blockly.Generator('NQC');
  
  nqcGenerator.ORDER_ATOMIC = 0;
  nqcGenerator.ORDER_NONE = 99;
  nqcGenerator.INDENT = '  ';
  
  // 初期化
  nqcGenerator.init = function(workspace) {
    nqcGenerator.definitions_ = Object.create(null);
    nqcGenerator.functionNames_ = Object.create(null);
    nqcGenerator.globalVariables_ = new Set();
    nqcGenerator.globalVarInitializations_ = new Map();
    nqcGenerator.workspace_ = workspace;
  };
  
  // 終了処理
  nqcGenerator.finish = function(code) {
    const definitions = [];
    
    // グローバル変数の定義
    if (nqcGenerator.globalVarInitializations_ && nqcGenerator.globalVarInitializations_.size > 0) {
      definitions.push('// グローバル変数');
      nqcGenerator.globalVarInitializations_.forEach((initValue, varName) => {
        definitions.push(`int ${varName} = ${initValue};`);
      });
      definitions.push('');
    }
    
    // その他の定義
    for (let name in nqcGenerator.definitions_) {
      definitions.push(nqcGenerator.definitions_[name]);
    }
    
    let finalCode = '// NQC Code Generated by Blockly\n';
    finalCode += '// LEGO MINDSTORMS RCX プログラム\n\n';
    
    if (definitions.length > 0) {
      finalCode += definitions.join('\n') + '\n\n';
    }
    
    if (nqcGenerator.mainTaskCode_) {
      finalCode += 'task main()\n{\n' + nqcGenerator.mainTaskCode_ + '}';
    } else {
      finalCode += 'task main()\n{\n  // メインタスクが定義されていません\n}';
    }
    
    return finalCode;
  };
  
  // ワークスペースからコード生成
  nqcGenerator.workspaceToCode = function(workspace) {
    if (!workspace) {
      console.error('workspaceToCode: workspaceがnull');
      return '';
    }
    nqcGenerator.init(workspace);
    nqcGenerator.mainTaskCode_ = null;
    
    const blocks = workspace.getTopBlocks(true);
    const code = [];
    let hasMainTask = false;
    
    // グローバル変数を処理
    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      if (block.type === 'variables_declare_global') {
        nqcGenerator.blockToCode(block);
      }
    }
    
    // タスクを処理
    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      if (block.type === 'task_main' || block.type === 'task_custom') {
        if (block.type === 'task_main') {
          hasMainTask = true;
        }
        const line = nqcGenerator.blockToCode(block);
        if (line) {
          code.push(line);
        }
      }
    }
    
    const finalCode = nqcGenerator.finish(code.join('\n'));
    return finalCode;
  };
  
  // ステートメントをコードに変換
  nqcGenerator.statementToCode = function(block, name) {
    const targetBlock = block.getInputTargetBlock(name);
    if (!targetBlock) {
      return '';
    }
    let code = nqcGenerator.blockToCode(targetBlock);
    if (typeof code === 'string') {
      // インデントを追加
      code = code.split('\n').map(line => line ? nqcGenerator.INDENT + line : line).join('\n');
      if (code && !code.endsWith('\n')) {
        code += '\n';
      }
    }
    return code;
  };
  
  // 値をコードに変換
  nqcGenerator.valueToCode = function(block, name, order) {
    order = order || nqcGenerator.ORDER_NONE;
    const targetBlock = block.getInputTargetBlock(name);
    if (!targetBlock) {
      return '';
    }
    const tuple = nqcGenerator.blockToCode(targetBlock);
    if (!Array.isArray(tuple)) {
      return '';
    }
    return tuple[0];
  };
  
  // ブロックをコードに変換
  nqcGenerator.blockToCode = function(block) {
    if (!block) {
      return '';
    }
    
    if (block.disabled) {
      // 次のブロックを処理
      return nqcGenerator.blockToCode(block.getNextBlock());
    }
    
    const func = nqcGenerator[block.type];
    if (!func) {
      console.warn('ジェネレータが見つかりません: ' + block.type);
      return '';
    }
    
    const code = func.call(block, block);
    if (Array.isArray(code)) {
      // 値ブロック
      return [nqcGenerator.scrub_(block, code[0]), code[1]];
    } else if (typeof code === 'string') {
      // ステートメントブロック
      const nextBlock = block.nextConnection && block.nextConnection.targetBlock();
      let nextCode = nqcGenerator.blockToCode(nextBlock);
      if (typeof nextCode === 'string' && nextCode) {
        // 空行の重複を避ける
        if (code.endsWith('\n') && nextCode.startsWith('\n')) {
          nextCode = nextCode.substring(1);
        }
        return code + nextCode;
      }
      return code;
    } else if (code === null) {
      return '';
    }
  };
  
  // インデント処理
  nqcGenerator.prefixLines = function(text, indent) {
    if (!text) {
      return '';
    }
    if (typeof indent === 'number') {
      indent = nqcGenerator.INDENT.repeat(indent);
    }
    const lines = text.split('\n');
    return lines.map(line => line ? indent + line : line).join('\n');
  };
  
  // =========================
  // ブロックジェネレータ定義
  // =========================
  
  // タスク
  nqcGenerator['task_main'] = function(block) {
    const statements = nqcGenerator.statementToCode(block, 'STATEMENTS');
    nqcGenerator.mainTaskCode_ = statements;
    return '';
  };
  
  nqcGenerator['task_custom'] = function(block) {
    const taskName = block.getFieldValue('TASKNAME');
    const statements = nqcGenerator.statementToCode(block, 'STATEMENTS');
    
    const taskCode = `task ${taskName}()\n{\n${statements}}\n`;
    nqcGenerator.definitions_['task_' + taskName] = taskCode;
    
    return '';
  };
  
  nqcGenerator['start_task'] = function(block) {
    const taskName = block.getFieldValue('TASKNAME');
    return `start ${taskName};\n`;
  };
  
  nqcGenerator['stop_task'] = function(block) {
    const taskName = block.getFieldValue('TASKNAME');
    return `stop ${taskName};\n`;
  };
  
  // モーター
  nqcGenerator['motor_on'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    return `On(${motors});\n`;
  };
  
  nqcGenerator['motor_off'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    return `Off(${motors});\n`;
  };
  
  nqcGenerator['motor_fwd'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    return `Fwd(${motors});\n`;
  };
  
  nqcGenerator['motor_rev'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    return `Rev(${motors});\n`;
  };
  
  nqcGenerator['motor_on_fwd'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    return `OnFwd(${motors});\n`;
  };
  
  nqcGenerator['motor_on_for'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    const time = nqcGenerator.valueToCode(block, 'TIME', nqcGenerator.ORDER_ATOMIC) || '100';
    return `OnFor(${motors}, ${time});\n`;
  };
  
  nqcGenerator['set_power'] = function(block) {
    const motors = block.getFieldValue('MOTORS');
    const power = block.getFieldValue('POWER');
    return `SetPower(${motors}, ${power});\n`;
  };
  
  // センサー
  nqcGenerator['set_sensor'] = function(block) {
    const port = block.getFieldValue('PORT');
    const type = block.getFieldValue('TYPE');
    return `SetSensor(SENSOR_${port}, ${type});\n`;
  };
  
  nqcGenerator['sensor_value'] = function(block) {
    const port = block.getFieldValue('PORT');
    return [`SENSOR_${port}`, nqcGenerator.ORDER_ATOMIC];
  };
  
  nqcGenerator['sensor_value_bool'] = function(block) {
    const port = block.getFieldValue('PORT');
    const portNum = parseInt(port) - 1;
    return [`SensorValueBool(${portNum})`, nqcGenerator.ORDER_ATOMIC];
  };
  
  nqcGenerator['clear_sensor'] = function(block) {
    const port = block.getFieldValue('PORT');
    return `ClearSensor(SENSOR_${port});\n`;
  };
  
  // タイマー
  nqcGenerator['timer_value'] = function(block) {
    const timer = block.getFieldValue('TIMER');
    return [`Timer(${timer})`, nqcGenerator.ORDER_ATOMIC];
  };
  
  nqcGenerator['clear_timer'] = function(block) {
    const timer = block.getFieldValue('TIMER');
    return `ClearTimer(${timer});\n`;
  };
  
  // 音
  nqcGenerator['play_sound'] = function(block) {
    const sound = block.getFieldValue('SOUND');
    return `PlaySound(${sound});\n`;
  };
  
  nqcGenerator['play_tone'] = function(block) {
    const freq = nqcGenerator.valueToCode(block, 'FREQ', nqcGenerator.ORDER_ATOMIC) || '440';
    const duration = nqcGenerator.valueToCode(block, 'DURATION', nqcGenerator.ORDER_ATOMIC) || '50';
    return `PlayTone(${freq}, ${duration});\n`;
  };
  
  nqcGenerator['play_note'] = function(block) {
    const frequency = block.getFieldValue('NOTE');
    const duration = block.getFieldValue('DURATION');
    return `PlayTone(${frequency}, ${duration});\n`;
  };
  
  // =========================
  // LCD表示ジェネレータ
  // =========================
  
  nqcGenerator['select_display'] = function(block) {
    const mode = block.getFieldValue('MODE');
    return `SelectDisplay(${mode});\n`;
  };
  
  nqcGenerator['set_user_display'] = function(block) {
    const value = nqcGenerator.valueToCode(block, 'VALUE', nqcGenerator.ORDER_ATOMIC) || '0';
    const precision = nqcGenerator.valueToCode(block, 'PRECISION', nqcGenerator.ORDER_ATOMIC) || '0';
    return `SetUserDisplay(${value}, ${precision});\n`;
  };
  
  // 待機
  nqcGenerator['wait'] = function(block) {
    const duration = nqcGenerator.valueToCode(block, 'DURATION', nqcGenerator.ORDER_ATOMIC) || '100';
    return `Wait(${duration});\n`;
  };
  
  // 変数
  nqcGenerator['variables_declare_global'] = function(block) {
    const varName = block.getFieldValue('VAR');
    const value = nqcGenerator.valueToCode(block, 'VALUE', nqcGenerator.ORDER_ATOMIC) || '0';
    
    nqcGenerator.globalVariables_.add(varName);
    if (nqcGenerator.globalVarInitializations_) {
      nqcGenerator.globalVarInitializations_.set(varName, value);
    }
    
    return '';
  };
  
  nqcGenerator['variables_get'] = function(block) {
    const varName = block.getFieldValue('VAR');
    return [varName, nqcGenerator.ORDER_ATOMIC];
  };
  
  nqcGenerator['variables_set'] = function(block) {
    const varName = block.getFieldValue('VAR');
    const value = nqcGenerator.valueToCode(block, 'VALUE', nqcGenerator.ORDER_ATOMIC) || '0';
    return `${varName} = ${value};\n`;
  };
  
  nqcGenerator['variables_change'] = function(block) {
    const varName = block.getFieldValue('VAR');
    const delta = nqcGenerator.valueToCode(block, 'DELTA', nqcGenerator.ORDER_ATOMIC) || '1';
    return `${varName} += ${delta};\n`;
  };
  
  // 算術演算
  nqcGenerator['math_number'] = function(block) {
    const code = parseFloat(block.getFieldValue('NUM'));
    return [code, nqcGenerator.ORDER_ATOMIC];
  };
  
  nqcGenerator['math_arithmetic'] = function(block) {
    const operator = block.getFieldValue('OP');
    const order = nqcGenerator.ORDER_ATOMIC;
    const argument0 = nqcGenerator.valueToCode(block, 'A', order) || '0';
    const argument1 = nqcGenerator.valueToCode(block, 'B', order) || '0';
    
    let code;
    switch (operator) {
      case 'ADD':
        code = argument0 + ' + ' + argument1;
        break;
      case 'MINUS':
        code = argument0 + ' - ' + argument1;
        break;
      case 'MULTIPLY':
        code = argument0 + ' * ' + argument1;
        break;
      case 'DIVIDE':
        code = argument0 + ' / ' + argument1;
        break;
      case 'POWER':
        code = `pow(${argument0}, ${argument1})`;
        break;
      default:
        code = '0';
    }
    
    return [code, order];
  };
  
  // 比較演算
  nqcGenerator['logic_compare'] = function(block) {
    const operator = block.getFieldValue('OP');
    const order = nqcGenerator.ORDER_ATOMIC;
    const argument0 = nqcGenerator.valueToCode(block, 'A', order) || '0';
    const argument1 = nqcGenerator.valueToCode(block, 'B', order) || '0';
    
    let code;
    switch (operator) {
      case 'EQ':
        code = argument0 + ' == ' + argument1;
        break;
      case 'NEQ':
        code = argument0 + ' != ' + argument1;
        break;
      case 'LT':
        code = argument0 + ' < ' + argument1;
        break;
      case 'LTE':
        code = argument0 + ' <= ' + argument1;
        break;
      case 'GT':
        code = argument0 + ' > ' + argument1;
        break;
      case 'GTE':
        code = argument0 + ' >= ' + argument1;
        break;
    }
    
    return [code, order];
  };
  
  // 論理演算
  nqcGenerator['logic_operation'] = function(block) {
    const operator = block.getFieldValue('OP');
    const order = nqcGenerator.ORDER_ATOMIC;
    const argument0 = nqcGenerator.valueToCode(block, 'A', order) || 'false';
    const argument1 = nqcGenerator.valueToCode(block, 'B', order) || 'false';
    
    let code;
    if (operator === 'AND') {
      code = argument0 + ' && ' + argument1;
    } else if (operator === 'OR') {
      code = argument0 + ' || ' + argument1;
    }
    
    return [code, order];
  };
  
  nqcGenerator['logic_negate'] = function(block) {
    const order = nqcGenerator.ORDER_ATOMIC;
    const argument0 = nqcGenerator.valueToCode(block, 'BOOL', order) || 'true';
    return ['!' + argument0, order];
  };
  
  nqcGenerator['logic_boolean'] = function(block) {
    const code = (block.getFieldValue('BOOL') === 'TRUE') ? 'true' : 'false';
    return [code, nqcGenerator.ORDER_ATOMIC];
  };
  
  // if-elseブロック
  nqcGenerator['if_else'] = function(block) {
    const condition = nqcGenerator.valueToCode(block, 'CONDITION', nqcGenerator.ORDER_ATOMIC) || 'false';
    const doStatements = nqcGenerator.statementToCode(block, 'DO');
    const elseStatements = nqcGenerator.statementToCode(block, 'ELSE');
    
    let code = `if (${condition})\n{\n${doStatements}}\n`;
    if (elseStatements) {
      code += `else\n{\n${elseStatements}}\n`;
    }
    
    return code;
  };
  
  // whileループ
  nqcGenerator['while_loop'] = function(block) {
    const condition = nqcGenerator.valueToCode(block, 'CONDITION', nqcGenerator.ORDER_ATOMIC) || 'false';
    const statements = nqcGenerator.statementToCode(block, 'DO');
    
    return `while (${condition})\n{\n${statements}}\n`;
  };
  
  // repeat回数指定ループ
  nqcGenerator['repeat_times'] = function(block) {
    const times = nqcGenerator.valueToCode(block, 'TIMES', nqcGenerator.ORDER_ATOMIC) || '1';
    const statements = nqcGenerator.statementToCode(block, 'DO');
    
    if (!statements || statements.trim() === '') {
      return '';
    }
    
    const loopVar = 'i';
    return `for (int ${loopVar} = 0; ${loopVar} < ${times}; ${loopVar}++)\n{\n${statements}}\n`;
  };
  
  // データログ
  nqcGenerator['create_datalog'] = function(block) {
    const size = nqcGenerator.valueToCode(block, 'SIZE', nqcGenerator.ORDER_ATOMIC) || '100';
    return `CreateDatalog(${size});\n`;
  };
  
  nqcGenerator['add_to_datalog'] = function(block) {
    const value = nqcGenerator.valueToCode(block, 'VALUE', nqcGenerator.ORDER_ATOMIC) || '0';
    return `AddToDatalog(${value});\n`;
  };
  
  // 制御構造
  nqcGenerator['controls_if'] = function(block) {
    let n = 0;
    let code = '', branchCode, conditionCode;
    do {
      conditionCode = nqcGenerator.valueToCode(block, 'IF' + n,
          nqcGenerator.ORDER_NONE) || 'false';
      branchCode = nqcGenerator.statementToCode(block, 'DO' + n);
      code += (n > 0 ? 'else ' : '') +
          'if (' + conditionCode + ')\n{\n' + branchCode + '}\n';
      n++;
    } while (block.getInput('IF' + n));

    if (block.getInput('ELSE')) {
      branchCode = nqcGenerator.statementToCode(block, 'ELSE');
      code += 'else\n{\n' + branchCode + '}\n';
    }
    return code;
  };
  
  nqcGenerator['controls_ifelse'] = nqcGenerator['controls_if'];
  
  nqcGenerator['controls_whileUntil'] = function(block) {
    const until = block.getFieldValue('MODE') === 'UNTIL';
    let argument0 = nqcGenerator.valueToCode(block, 'BOOL',
        until ? nqcGenerator.ORDER_LOGICAL_NOT :
        nqcGenerator.ORDER_NONE) || 'false';
    const branch = nqcGenerator.statementToCode(block, 'DO');
    if (until) {
      argument0 = '!' + argument0;
    }
    return 'while (' + argument0 + ')\n{\n' + branch + '}\n';
  };
  
  nqcGenerator['controls_for'] = function(block) {
    const variable0 = 'i';
    const argument0 = nqcGenerator.valueToCode(block, 'FROM',
        nqcGenerator.ORDER_ASSIGNMENT) || '0';
    const argument1 = nqcGenerator.valueToCode(block, 'TO',
        nqcGenerator.ORDER_ASSIGNMENT) || '0';
    const increment = nqcGenerator.valueToCode(block, 'BY',
        nqcGenerator.ORDER_ASSIGNMENT) || '1';
    const branch = nqcGenerator.statementToCode(block, 'DO');
    
    let code = 'for (int ' + variable0 + ' = ' + argument0 + '; ' +
        variable0 + ' <= ' + argument1 + '; ' +
        variable0 + ' += ' + increment + ')\n{\n' + branch + '}\n';
    return code;
  };
  
  return nqcGenerator;
}
